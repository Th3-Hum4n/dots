# $HOME/etc/bashrc 
# If not running interactively, don't do anything
[[ $- != *i* ]] && return

# colors and their ANSI codes. made colorful prompt easy
blk="\[\033[38;5;0m\]"
red="\[\033[38;5;1m\]"
grn="\[\033[38;5;2m\]"
ylw="\[\033[38;5;3m\]"
blu="\[\033[38;5;4m\]"
pnk="\[\033[38;5;5m\]"
cyn="\[\033[38;5;6m\]"
wht="\[\033[38;5;7m\]"
dblk="\[\033[38;5;8m\]"
dred="\[\033[38;5;9m\]"
dgrn="\[\033[38;5;10m\]"
dylw="\[\033[38;5;11m\]"
dblu="\[\033[38;5;12m\]"
dpnk="\[\033[38;5;13m\]"
dcyn="\[\033[38;5;14m\]"
dwht="\[\033[38;5;15m\]"

# check the current git branch
# read the comments to understand
_branch() {
    local branch="$(git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ \1/')"
    local branch_status=0
    
    # branch_status=0 => unmodified
    # branch_status=1 => modified
    # branch_status=2 => the local repo is ahead
    # TODO: add support for checking if the local repo is not up to date

    if [ -n "$branch" ]; then
        case "$(git status -uno 2> /dev/null)" in
            *"Changes to be committed"* | *"not staged"*)
            branch_status=1;;
            *"ahead of"*)
            branch_status=2;;
            *"up to date"*)
            branch_status=0;;
        esac
        
        case $branch_status in
        0)
        echo -n "$branch";;
        1)
        echo -n "${branch}+";;
        2)
        echo -n "${branch}^";;
        esac
    fi
}

# set our terminal's window terminal to the current working dir
_get_cwd() {
    # we don't want to set the terminal window's name if we're in a tty
    if [ "$TERM" != "linux" ]; then
        local cwd="$(echo "$PWD" | sed -e "s|$HOME|\$HOME|g" 2> /dev/null)"
        echo -ne "\033]0;$cwd\a" 2> /dev/null
    fi
}

# prompt
case "$(whoami)" in
    the_human)
        export PS1="${red}t${grn}h${ylw}e${blu}_${pnk}h${cyn}u${dred}m${dpnk}a${dblu}n ${dblu}\w\[$(tput sgr0)\]${dcyn}\$(_branch)\[\$(_get_cwd)\]\[\033[0m\] "
    ;;
    root)
        export PS1="${red}r${pnk}o${blu}o${grn}t ${dgrn}\w\[$(tput sgr0)\]${dcyn}\$(_branch)\$(_get_cwd)\[\003[0m\] "
    ;;
esac

# update history so we can share the same history between terms
shopt -s histappend
export PROMPT_COMMAND="history -a; history -c; history -r; $PROMPT_COMMAND"

# export a bunch of variables
# I prefer to have binaries and other scripts in my home dir, so I add some some directories to my $PATH
export EDITOR=nvim
export PATH=$PATH:$HOME/bin/:$HOME/.local/bin:$HOME/usr/local:$HOME/usr/local/bin
export MANPATH=$MANPATH:$HOME/usr/local/man

# source aliases
source $HOME/etc/aliases

# set vi mode
set -o vi

# infinite history
HISTFILESIZE= HISTSIZE=
HISTFILE="$HOME/var/cache/bash_history"

# console stuff
if [ "$TERM" == "linux" ]; then
    # set our console font. (I'm too lazy to setup a systemd service for this)
    setfont $HOME/var/fonts/terminus-font-4.46/ter-v12n.psf
    # set the colorscheme!
    source $HOME/etc/conscols
    clear # we have to clear the console to see the changes
fi
