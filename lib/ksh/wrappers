# -*- mode: sh -*-

# The following two functions are here to help me select tabs/windows
# Setting title to running command is way too hacky and cumbersome
man() {
	__settitle man ${*}
	cmd man "${@}"
}

less() {
	if [[ ! -t 0 ]]; then
		__settitle 'less <stdin>'
	else
		__settitle "less ${*}"
	fi
	cmd less "${@}"
}

v() vis "${@}";

has git && {
	git() {
		case ${1} {
		ignore-get)
			wget -O .gitignore \
		https://raw.githubusercontent.com/github/gitignore/master/${2}.gitignore
			;;
		squash)
			local cnf
			read -r cnf?'do you want to continue? '
			[[ "${cnf:0:1}" != @(y|Y) ]] && return 0
			cmd git reset --soft HEAD~${2}
			shift 2
			cmd git commit -m "${@}"
			;;
		com|commit)
			shift
			[[ -n "${1}" ]] && cmd git commit -m "${@}" ||
					cmd git commit
			;;
		clone)
			local fnl="${@}"
			[[ "${2}" != *viz* ]] && fnl="${@} --depth 1"
			cmd git ${fnl}
			;;
		*)
			cmd git "${@}"
			;;
		}
	}
	a diff='git diff --no-color'
}

has emacs && {
	remacs() {
		pgrep -x emacs >/dev/null && pkill emacs
		emacs --daemon
	}

	v() {
		! pgrep -x emacs >/dev/null || ! pgrep -x X >/dev/null && {
			vis "${@}"
			return ${?}
		}
		xembed --parent-id emacsclient "${@}" || emacsclient "${@}"
	}

	# Inside M-x shell
	[[ -n "${INSIDE_EMACS}" ]] && [[ "${TERM}" = dumb ]] && {
		# TODO:  * Change pager to view-file mode instead?
		MANPAGER='cat' PAGER='cat'
		export MANPAGER PAGER

		elisp-shell() {
			elisp - <<EOF
(with-current-buffer
    (window-buffer (selected-window))
  ${@})
EOF
		}

		racket() {
			elisp-shell '(setq-local comint-process-echoes nil)' >/dev/null
			command racket "${@}"
			elisp-shell '(setq-local comint-process-echoes t)' >/dev/null
		}

		v() {
			elisp "(find-file \"${@}\")"
		}

		clear() {
			:
			# elisp-shell '(comint-clear-buffer)' >/dev/null
		}

		transmission() {
			pgrep -x transmission-dae || transmission-daemon
			elisp -t '(transmission)'
		}

		trans() transmission;

		# Woman can be really slow on large man pages
		man() {
			case ${*} in
			*configuration.nix)
				st -e man -P less "${@}" >/dev/null 2>&1
				;;
			*)
				if [[ ! -t 0 ]]; then
					local t=`mktemp`
					cat ->${t}
					elisp "(pop-to-buffer-same-window (man \"-l ${t}\"))
					   (delete-file \"${t}\")" >/dev/null
				else
					elisp "(pop-to-buffer-same-window (man \"${*}\"))" >/dev/null
				fi
				;;
			esac
		}

		less() {
			if [[ ! -t 0 ]]; then
				local t=`mktemp`
				sed -E 's/[\x01-\x1F\x7F]\[[0-9;]+m//g' >${t}
				elisp "(view-file \"${t}\") (delete-file \"${t}\")" >/dev/null
			else
				elisp "(view-file \"${@}\")" >/dev/null
			fi
		}

		for i in top alsamixer vidir transmission-cli ircdiscord; {
			eval "
${i}() {
	   st -e "${i} \"\${@}\"" >/dev/null 2>&1 &
}
"
		}
	}
}

has mpv && {
	muss() {
		mpv "${1:-.}" --shuffle
	}
}

has nix && {
	_nxsh() {
		local inpkgs=0 NIX_SHELL_PACKAGES args
		args=("${@}")
		while ((${#}>0)); do
			case ${1} {
			-p|--packages)
				inpkgs=1
				NIX_SHELL_PACKAGES+=("${2}")
				shift
				;;
			--arg|--argstr)
				inpkgs=0
				shift 2
				;;
			-*)
				inpkgs=0
				;;
			*)
				[[ ${inpkgs} -eq 1 ]] &&
					NIX_SHELL_PACKAGES+=("${1}")
				;;
			}
			shift
		done
		NIX_SHELL_PACKAGES="${NIX_SHELL_PACKAGES[@]}" \
			NIX_BUILD_SHELL="${HOME}/lib/ksh/.nxsh" \
			NIX_EXECUTING_SHELL="${SHELL}" nix-shell "${args[@]}"
	}

	nx() {
		case ${1} {
		sr)
			shift
			[[ -z "${@}" ]] && return 0
			find /nix/store -maxdepth 1 -type d `
				for i; {
					print -- "-name *${i}*"
				}`
			;;
		shl)
			[[ -f shell.nix ]] && {
				print error: shell.nix already exists
				return 1
			}
			cat >shell.nix <<EOF
with import <nixpkgs> {};

stdenv.mkDerivation rec {
  name = "-environment";

  buildInputs = [];
  nativeBuildInputs = [];
}
EOF
			;;
		sh)
			shift 1
			_nxsh "${@}"
			;;
		pkg)
			[[ -f ${2} ]] && {
				print error: ${2} already exists
				return 1
			}
			[[ -z ${2} ]] && {
				print error: no file argument given
				return 1
			}
			cat >${2} <<EOF
{ stdenv, fetch }:

stdenv.mkDerivation rec {
  pname = "";
  version = "";
  src = fetch {
  };

  buildInputs = [];
  nativeBuildInputs = [];

  patches = [];

  makeFlags = [];
  installFlags = [];

  meta = with stdenv.lib; {
    description = "";
    homepage = "";
    license = licenses.;
    platforms = platforms.linux;
  };
}
EOF
			;;
		*)
			cat <<EOF
usage: nx [shl|pkg file|sh ...|sr ...]
	shl: create shell.nix template
	pkg: write package template
	sh: start nix-shell
	sr: search in /nix/store
EOF
			;;
		}
	}
}
